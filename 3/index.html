<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <!-- NgƒÉn tr√¨nh duy·ªát thu ph√≥ng b·∫±ng double-tap v√† cho web app ch·∫°y full-screen khi th√™m v√†o m√†n h√¨nh ch√≠nh iOS -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="format-detection" content="telephone=no" />
  <title>ƒê√†n Piano</title>
  <style>
    :root{
      --white-key-height:150px;
      --black-key-height:90px;
      --white-key-height-landscape:220px;
      --black-key-height-landscape:130px;
      --white-key-bg: linear-gradient(to bottom, #fff 0%, #ececec 100%);
      --white-key-border: 2px solid #222;
      --black-key-bg: linear-gradient(to bottom, #444 0%, #091a21 100%);
      --active-green-w: linear-gradient(137deg, #2ecc71 0%, #27ae60 100%);
      --active-green-b: linear-gradient(137deg, #1fa86a 0%, #13914f 100%);
    }

    /* --- Global app no-select/callout to eliminate copy menu within app area --- */
    html, body {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none; /* iOS callout */
      -webkit-tap-highlight-color: transparent;
      /* Do NOT set a blanket touch-action: manipulation on all descendants (may override .piano) */
      touch-action: auto;
    }
    /* apply to the app wrapper and all descendants (no blanket touch-action) */
    #appWrap, #appWrap * {
      -webkit-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-user-drag: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    /* ---- keep piano handling as before (no gestures inside piano) ---- */
    .piano { touch-action: none !important; } /* ensure piano disables browser gestures for consistent touch handling */

    html,body{height:100%;margin:0;font-family:Arial, Helvetica, sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-font-smoothing:antialiased;}
    .wrap{max-width:1240px;margin:0 auto;padding:20px;box-sizing:border-box;position:relative;}

    /* --- Sound control styles --- */
    .sound-control,
    .sound-control * {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation; /* controls can accept simple taps */
    }

    .sound-control {
      position: fixed;
      top:14px;
      right:14px;
      z-index:9999;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      pointer-events: auto;
    }
    .sound-toggle {
      background: linear-gradient(145deg, #2ac7ec, #1594bb);
      color:#fff;border:0;border-radius:50%;width:44px;height:44px;font-size:20px;cursor:pointer;
      display:flex;align-items:center;justify-content:center;box-shadow:0 6px 18px rgba(0,0,0,0.24);
      touch-action: manipulation;
    }
    .sound-toggle.muted{background:linear-gradient(145deg,#f44336,#d32f2f);}
    .sound-label{
      color:#fff;font-weight:600;font-size:13px;text-shadow:0 1px 3px rgba(0,0,0,0.25);
      display:block;white-space:nowrap;
      pointer-events: auto;
    }

    /* Piano container */
    .piano-container {
      margin:40px auto 8px;
      background: rgba(0,0,0,0.18);
      backdrop-filter: blur(8px);
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 9px 28px rgba(0,0,0,0.39);
      overflow: auto;
    }
    .piano {
      position: relative;
      height: var(--white-key-height);
      margin: 0 auto;
      touch-action: none;
      min-width: 320px;
      user-select: none;
    }
    /* Landscape modifier: k√©o d√†i b√†n ph√≠m theo chi·ªÅu ƒë·ª©ng */
    body.landscape .piano {
      height: var(--white-key-height-landscape);
    }

    .white-key {
      position: absolute;
      height: var(--white-key-height);
      background: var(--white-key-bg);
      border: var(--white-key-border);
      border-radius: 0 0 6px 6px;
      cursor: pointer;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:6px;
      font-size:11px;
      color:#555;
      font-weight:700;
      box-sizing: border-box;
      transition: all 0.06s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    body.landscape .white-key {
      height: var(--white-key-height-landscape);
      padding-bottom:10px;
      font-size:12px;
    }
    .white-key.active { background: var(--active-green-w); color:#083; box-shadow: 0 6px 12px rgba(18, 88, 59, 0.18); transform: translateY(0px); }

    .black-key {
      position: absolute;
      height: var(--black-key-height);
      background: var(--black-key-bg);
      border: 1px solid #111;
      border-radius: 0 0 5px 5px;
      cursor:pointer;
      z-index: 9;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:4px;
      font-size:10px;
      color:#fff;
      font-weight:700;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
      transition: all 0.05s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    body.landscape .black-key {
      height: var(--black-key-height-landscape);
      padding-bottom:6px;
      font-size:11px;
    }
    .black-key.active { background: var(--active-green-b); color:#eaffea; box-shadow: 0 6px 12px rgba(20, 80, 50, 0.18); transform: translateY(0px); }

    /* Portrait hint text below piano */
    .portrait-hint {
      text-align: center;
      color: #fff;
      font-weight:700;
      margin: 10px 0 26px;
      font-size: 15px;
      text-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    /* Hide the hint when in landscape */
    body.landscape .portrait-hint { display: none; }

    /* Hide scrollbars on iOS Safari while allowing scroll */
    .piano-container::-webkit-scrollbar{height:8px}
    .piano-container::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.2);border-radius:8px}

    /* Responsive tweaks */
    @media (max-width:900px){
      :root{--white-key-height:120px;--black-key-height:72px;}
      body.landscape {
        --white-key-height-landscape:200px;
        --black-key-height-landscape:120px;
      }
    }
    @media (max-width:480px){
      :root{--white-key-height:100px;--black-key-height:60px;}
      body.landscape {
        --white-key-height-landscape:170px;
        --black-key-height-landscape:110px;
      }
    }
  </style>
</head>
<body>
  <div id="appWrap" class="wrap">
    <div class="sound-control" id="soundControl">
      <button id="soundToggle" class="sound-toggle muted" aria-pressed="false" title="K√≠ch ho·∫°t √¢m">
        <span id="soundIcon">üîá</span>
      </button>
      <span id="soundStatus" class="sound-label">T·∫Øt</span>
    </div>

    <div class="piano-container" id="pianoContainer" aria-hidden="false">
      <div class="piano" id="piano" role="application" aria-label="B√†n ph√≠m piano"></div>
    </div>

    <div id="portraitHint" class="portrait-hint">‚§¥Ô∏è Xoay ngang ƒë·ªÉ hi·ªÉn th·ªã full b√†n ph√≠m</div>
  </div>

  <script>
    // ========= Êï∞ÊçÆ & audio ==========
    const pianoNotes = [
      'C3','C#3','D3','D#3','E3','F3','F#3','G3','G#3','A3','A#3','B3',
      'C4','C#4','D4','D#4','E4','F4','F#4','G4','G#4','A4','A#4','B4',
      'C5','C#5','D5','D#5','E5','F5','F#5','G5','G#5','A5'
    ];
    const notesFreq = {
      'C3':130.81,'C#3':138.59,'D3':146.83,'D#3':155.56,'E3':164.81,'F3':174.61,'F#3':185.00,
      'G3':196.00,'G#3':207.65,'A3':220.00,'A#3':233.08,'B3':246.94,
      'C4':261.63,'C#4':277.18,'D4':293.66,'D#4':311.13,'E4':329.63,'F4':349.23,'F#4':369.99,
      'G4':392.00,'G#4':415.30,'A4':440.00,'A#4':466.16,'B4':493.88,
      'C5':523.25,'C#5':554.37,'D5':587.33,'D#5':622.25,'E5':659.25,'F5':698.46,'F#5':739.99,
      'G5':783.99,'G#5':830.61,'A5':880.00
    };
    const sampleBaseURL = "https://raw.githubusercontent.com/Nhut11790/nhut11790.github.io/main/tieng/";
    const pianoFolder = "acoustic_grand_piano-mp3";

    let audioContext = null;
    let isAudioActivated = false; // whether AudioContext activation flow completed
    let isMuted = true;
    const sampleBuffers = {};
    const preloadState = { started: false, done: false };

    function initAudioContext(){
      if(!audioContext){
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if(audioContext.state === 'suspended') {
        audioContext.resume().catch(()=>{});
      }
    }

    // decodeAudioData wrapper for broad compatibility (Promise + callback fallback)
    function decodeAudioDataAsync(ctx, arrayBuffer){
      return new Promise((resolve, reject) => {
        try {
          const p = ctx.decodeAudioData(arrayBuffer, resolve, reject);
          // Some browsers return a promise
          if (p && typeof p.then === 'function'){
            p.then(resolve).catch(reject);
          }
        } catch(err){
          reject(err);
        }
      });
    }

    function convertSharpToFlat(note){
      const sharpToFlat = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
      for (let sharp in sharpToFlat) {
        if (note.startsWith(sharp)) return note.replace(sharp, sharpToFlat[sharp]);
      }
      return note;
    }

    // Preload with concurrency limit to avoid overwhelming mobile memory/network
    async function preloadPiano(concurrency = 5){
      if(preloadState.started) return;
      preloadState.started = true;
      initAudioContext();

      const notesToLoad = pianoNotes.slice(); // copy
      let idx = 0;
      const active = [];

      function next(){
        if(idx >= notesToLoad.length) return null;
        const note = notesToLoad[idx++];
        const flat = convertSharpToFlat(note);
        const fileName = flat + '.mp3';
        const url = `${sampleBaseURL}${pianoFolder}/${fileName}`;
        const p = fetch(url)
          .then(r => {
            if(!r.ok) throw new Error('Network');
            return r.arrayBuffer();
          })
          .then(buf => decodeAudioDataAsync(audioContext, buf.slice(0)))
          .then(audioBuf => { sampleBuffers[note] = audioBuf; })
          .catch(err => { /* ignore individual failures */ });
        return p;
      }

      // kick off initial workers
      for(let i=0;i<concurrency;i++){
        const p = (async function worker(){
          while(true){
            const job = next();
            if(!job) break;
            await job;
          }
        })();
        active.push(p);
      }

      await Promise.all(active);
      preloadState.done = true;
      // console.log('Preload done, loaded:', Object.keys(sampleBuffers).length);
    }

    async function playSample(note, volume=1.0, duration=1100){
      if(!audioContext || !isAudioActivated) return;
      if(isMuted) return;
      let buffer = sampleBuffers[note];
      let rootNote = note;
      if(!buffer){
        // try best-approximate buffer (closest frequency)
        const available = Object.keys(sampleBuffers);
        if(available.length===0){
          // on-demand load attempt (fallback): fetch and decode synchronously (best-effort)
          try{
            initAudioContext();
            const flat = convertSharpToFlat(note);
            const url = `${sampleBaseURL}${pianoFolder}/${flat}.mp3`;
            const r = await fetch(url);
            if(!r.ok) return;
            const ab = await r.arrayBuffer();
            buffer = await decodeAudioDataAsync(audioContext, ab);
            sampleBuffers[note] = buffer;
            rootNote = note;
          }catch(e){
            return;
          }
        } else {
          let best = available[0], bestDiff = Math.abs(notesFreq[best]-notesFreq[note]);
          for(const n of available){
            const d = Math.abs(notesFreq[n]-notesFreq[note]);
            if(d<bestDiff){bestDiff=d;best=n;}
          }
          buffer = sampleBuffers[best];
          rootNote = best;
        }
      }
      try{
        const src = audioContext.createBufferSource();
        src.buffer = buffer;
        const semitone = Math.log2(notesFreq[note] / notesFreq[rootNote]) * 12;
        src.playbackRate.value = Math.pow(2, semitone/12);
        const gain = audioContext.createGain();
        gain.gain.value = volume;
        src.connect(gain); gain.connect(audioContext.destination);
        src.start();
        // stop after either duration or buffer duration scaled by playbackRate
        const maxDur = Math.min(duration/1000, src.buffer.duration / Math.max(src.playbackRate.value, 0.0001));
        try{ src.stop(audioContext.currentTime + maxDur); }catch(e){}
      }catch(e){ /* ignore play errors */ }
    }

    // ========= Render piano ==========
    const pianoDiv = document.getElementById('piano');
    const pianoContainer = document.getElementById('pianoContainer');
    const appWrap = document.getElementById('appWrap');

    function getWhiteKeys(){
      const whites = [];
      pianoNotes.forEach(note=>{
        const m = note.match(/^([A-G])([#]?)(\d)$/);
        if(m && !m[2]) whites.push({note:note, key:m[1], octave:m[3]});
      });
      return whites;
    }

    function renderPiano(){
      pianoDiv.innerHTML = '';
      const whites = getWhiteKeys();
      const whiteCount = whites.length;
      const containerW = Math.max(pianoContainer.clientWidth - 20, window.innerWidth - 40);
      const isLandscape = window.innerWidth > window.innerHeight;
      let keyWidth;
      if(isLandscape){
        keyWidth = Math.floor(containerW / whiteCount);
        keyWidth = Math.max(28, Math.min(keyWidth, 80));
      } else {
        const defaultW = 33;
        const maxFitWidth = Math.floor(containerW / whiteCount);
        keyWidth = Math.min(defaultW, Math.max(24, maxFitWidth)) || Math.min(defaultW, Math.max(24, containerW / whiteCount));
      }
      const pianoWidth = whiteCount * keyWidth;
      pianoDiv.style.width = pianoWidth + 'px';

      whites.forEach((w,i)=>{
        const left = i * keyWidth;
        const key = document.createElement('div');
        key.className = 'white-key';
        key.dataset.note = w.note;
        key.textContent = w.note;
        key.style.left = left + 'px';
        key.style.width = keyWidth + 'px';
        key.id = 'key_' + w.note;
        key.setAttribute('tabindex','0'); // accessible
        key.setAttribute('role','button');
        key.setAttribute('aria-pressed','false');
        bindKeyEvents(key, w.note);
        pianoDiv.appendChild(key);
      });

      const blackMap = {'C':'C#','D':'D#','F':'F#','G':'G#','A':'A#'};
      const blackWidth = Math.max( Math.floor(keyWidth * 0.62), 16 );
      whites.forEach((w,i)=>{
        const b = blackMap[w.key];
        if(!b) return;
        const blackNote = b + w.octave;
        if(!pianoNotes.includes(blackNote)) return;
        // nicer centering for black keys
        const left = Math.round(i * keyWidth + keyWidth - blackWidth/2 - (blackWidth>keyWidth?0: (blackWidth/8)));
        const k = document.createElement('div');
        k.className = 'black-key';
        k.dataset.note = blackNote;
        k.textContent = blackNote;
        k.style.left = left + 'px';
        k.style.width = blackWidth + 'px';
        k.id = 'key_' + blackNote;
        k.setAttribute('tabindex','0');
        k.setAttribute('role','button');
        k.setAttribute('aria-pressed','false');
        bindKeyEvents(k, blackNote);
        pianoDiv.appendChild(k);
      });
    }

    // ========= Pointer / touch / multi-touch handling ==========
    // We implement:
    // - PointerEvent path (preferred, supports multi-touch & pointer capture)
    // - Fallback: touchstart/touchend with touch id mapping + mouse events
    const touchToElement = new Map(); // touchId -> element
    let globalTouchHandlersInstalled = false;

    function bindKeyEvents(el, note){
      // Helper to mark active state
      function makeActive(element){
        if(!element) return;
        element.classList.add('active');
        element.setAttribute('aria-pressed','true');
      }
      function makeInactive(element){
        if(!element) return;
        element.classList.remove('active');
        element.setAttribute('aria-pressed','false');
      }

      // PointerEvent handlers
      const onPointerDown = (e) => {
        // ignore non-primary mouse buttons
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        try{ e.preventDefault(); }catch(e){}
        if(!isAudioActivated){ flashAlertOnce(); }
        makeActive(el);
        try{ if(el.setPointerCapture) el.setPointerCapture(e.pointerId); }catch(err){}
        playSample(note, 1.0);
      };
      const onPointerUp = (e) => {
        try{ if(e && e.preventDefault) e.preventDefault(); }catch(e){}
        makeInactive(el);
        try{ if(e && e.pointerId && el.releasePointerCapture) el.releasePointerCapture(e.pointerId); }catch(err){}
      };

      // Touch fallback per-element: only used when PointerEvent unsupported.
      const onTouchStart = (ev) => {
        // prevent page scroll when tapping piano keys
        if(ev.cancelable) ev.preventDefault();
        for(const t of ev.changedTouches){
          touchToElement.set(t.identifier, el);
          makeActive(el);
          playSample(note, 1.0);
        }
      };
      const onMouseDown = (ev) => {
        if(ev.button !== 0) return;
        ev.preventDefault();
        makeActive(el);
        playSample(note, 1.0);
      };
      const onMouseUp = (ev) => {
        makeInactive(el);
      };

      // Keyboard accessibility
      const onKeyDown = (e) => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          if(!el.classList.contains('active')) {
            makeActive(el);
            playSample(note, 1.0);
          }
        }
      };
      const onKeyUp = (e) => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          makeInactive(el);
        }
      };

      // Attach appropriate handlers
      if(window.PointerEvent){
        el.addEventListener('pointerdown', onPointerDown);
        el.addEventListener('pointerup', onPointerUp);
        el.addEventListener('pointercancel', onPointerUp);
        el.addEventListener('lostpointercapture', onPointerUp);
      } else {
        // touch & mouse fallback
        el.addEventListener('touchstart', onTouchStart, {passive:false});
        el.addEventListener('mousedown', onMouseDown);
        el.addEventListener('mouseup', onMouseUp);
        el.addEventListener('mouseleave', onMouseUp);
        // Install global touchend/ cancel handler once to map changedTouches -> elements
        if(!globalTouchHandlersInstalled){
          globalTouchHandlersInstalled = true;
          document.addEventListener('touchend', (ev) => {
            for(const t of ev.changedTouches){
              const el = touchToElement.get(t.identifier);
              if(el){
                el.classList.remove('active');
                el.setAttribute('aria-pressed','false');
                touchToElement.delete(t.identifier);
              }
            }
          }, {passive:false});
          document.addEventListener('touchcancel', (ev) => {
            for(const t of ev.changedTouches){
              const el = touchToElement.get(t.identifier);
              if(el){
                el.classList.remove('active');
                el.setAttribute('aria-pressed','false');
                touchToElement.delete(t.identifier);
              }
            }
          }, {passive:false});
        }
      }

      // Common handlers
      el.addEventListener('contextmenu', (ev) => ev.preventDefault());
      el.addEventListener('selectstart', (ev) => ev.preventDefault());
      el.addEventListener('dblclick', (e)=> e.preventDefault());
      el.addEventListener('keydown', onKeyDown);
      el.addEventListener('keyup', onKeyUp);

      // ensure element is focusable
      if(!el.hasAttribute('tabindex')) el.setAttribute('tabindex','0');
    }

    // ========== UI helpers ==========
    let alertShown = false;
    function flashAlertOnce(){
      if(alertShown) return;
      alertShown = true;
      const s = document.getElementById('soundStatus');
      const orig = s.textContent;
      s.textContent = 'B·∫•m n√∫t k√≠ch √¢m ƒë·ªÉ b·∫≠t';
      s.style.color = '#FFD700';
      setTimeout(()=>{ s.textContent = orig; s.style.color=''; alertShown=false; }, 1600);
    }

    // ========== Prevent copy/menu when long-pressing anywhere inside appWrap ==========
    document.addEventListener('contextmenu', (e) => {
      if (appWrap && appWrap.contains(e.target)) {
        e.preventDefault();
      }
    }, {passive:false});
    document.addEventListener('selectstart', (e) => {
      if (appWrap && appWrap.contains(e.target)) {
        e.preventDefault();
      }
    }, {passive:false});
    document.addEventListener('selectionchange', () => {
      try {
        const sel = document.getSelection();
        if (!sel) return;
        if (sel.isCollapsed) return;
        const anchor = sel.anchorNode;
        const focus = sel.focusNode;
        if ((anchor && appWrap.contains(anchor)) || (focus && appWrap.contains(focus))) {
          sel.removeAllRanges();
        }
      } catch (err) { /* ignore */ }
    });
    document.addEventListener('copy', (e) => {
      try {
        const sel = document.getSelection();
        if ( (sel && sel.anchorNode && appWrap.contains(sel.anchorNode)) || (e.target && appWrap.contains(e.target)) ) {
          e.preventDefault();
        }
      } catch (err) {}
    }, {passive:false});

    // Also explicitly block contextmenu on sound controls
    const soundToggle = document.getElementById('soundToggle');
    const soundStatus = document.getElementById('soundStatus');
    const soundControl = document.getElementById('soundControl');
    [soundToggle, soundStatus, soundControl].forEach(el=>{
      if(!el) return;
      el.addEventListener('contextmenu', e => e.preventDefault());
      el.addEventListener('selectstart', e => e.preventDefault());
      el.addEventListener('touchstart', (e)=> e.stopPropagation(), {passive:true});
    });

    // ========== Orientation / render handling ==========
    function applyOrientationClass(){
      const isLandscape = window.innerWidth > window.innerHeight;
      document.body.classList.toggle('landscape', isLandscape);
      const hint = document.getElementById('portraitHint');
      if(!isLandscape){
        hint.style.display = '';
      } else {
        hint.style.display = 'none';
      }
      renderPiano();
    }

    let resizeTimer = null;
    function handleResize(){
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{ applyOrientationClass(); resizeTimer = null; }, 120);
    }
    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);

    // ========== Prevent double-tap zoom (iOS & others) ==========
    (function preventDoubleTapZoom(){
      let lastTouch = 0;
      document.addEventListener('touchend', function(e){
        const t = e.target;
        if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) {
          lastTouch = Date.now();
          return;
        }
        const now = Date.now();
        if (now - lastTouch <= 300) {
          if(e.cancelable) e.preventDefault();
        }
        lastTouch = now;
      }, {passive:false});
    })();

    // ========== Sound activation & toggle (iOS friendly) ==========
    // Button acts as: first click activates audio system (on iOS resume + test play),
    // subsequent clicks toggle mute/unmute.
    soundToggle.addEventListener('click', async ()=>{
      // If not activated yet, run activation flow
      if(!isAudioActivated){
        soundToggle.disabled = true;
        document.getElementById('soundIcon').textContent = '‚è≥';
        soundStatus.textContent = 'ƒêang k√≠ch ho·∫°t...';
        try{
          initAudioContext();
          // small test play to satisfy iOS autoplay restrictions: try to play a tiny mp3 via <audio>
          const testUrl = `${sampleBaseURL}${pianoFolder}/E3.mp3`;
          const tAudio = new Audio(testUrl);
          tAudio.volume = 0.08;
          await new Promise((resolve,reject)=>{
            const onCan = async ()=> {
              try {
                await tAudio.play();
                setTimeout(()=>{ try{ tAudio.pause(); }catch(e){}; tAudio.currentTime=0; resolve(); }, 200);
              } catch(err){ reject(err); }
            };
            tAudio.addEventListener('canplaythrough', onCan, {once:true});
            tAudio.addEventListener('error', ()=>reject(new Error('Kh√¥ng t·∫£i ƒë∆∞·ª£c test audio')), {once:true});
            tAudio.load();
            setTimeout(()=>reject(new Error('Timeout')),4000);
          });
          try{ await audioContext.resume(); }catch(e){}
          isAudioActivated = true;
          isMuted = false;
          soundToggle.classList.remove('muted');
          document.getElementById('soundIcon').textContent = 'üîä';
          soundStatus.textContent = 'B·∫≠t';
          soundToggle.disabled = false;
          soundToggle.setAttribute('aria-pressed','true');
          // preload in background (throttled)
          preloadPiano(5).then(()=>{/* done */});
        }catch(err){
          soundToggle.disabled = false;
          document.getElementById('soundIcon').textContent = 'üîá';
          soundStatus.textContent = 'Th·ª≠ l·∫°i';
          console.warn('K√≠ch ho·∫°t audio th·∫•t b·∫°i', err);
          alert('‚ö†Ô∏è Kh√¥ng th·ªÉ k√≠ch ho·∫°t √¢m thanh.\n\nL·ªói: ' + (err && err.message ? err.message : err));
        }
        return;
      }

      // If already activated -> toggle mute/unmute
      isMuted = !isMuted;
      soundToggle.classList.toggle('muted', isMuted);
      document.getElementById('soundIcon').textContent = isMuted ? 'üîá' : 'üîä';
      soundStatus.textContent = isMuted ? 'T·∫Øt' : 'B·∫≠t';
      soundToggle.setAttribute('aria-pressed', String(!isMuted));
    });

    // ========== Init on load ==========
    window.addEventListener('load', async ()=>{
      applyOrientationClass();
      try{
        initAudioContext();
        // Start preload eagerly except on some iOS devices where early resume may be blocked:
        // We still preload but only decode when activation happens. We keep network + decode behavior
        // inside preloadPiano, and it will be triggered after user activates (we call preload on activate).
        // To keep responsiveness, we attempt a background preload if not iOS.
        if(!/iP(hone|ad|od).*OS/.test(navigator.userAgent)){
          // attempt preload but audioContext may be suspended; decodeAudioData will still work after resume
          preloadPiano(5);
        }
      }catch(e){}
    });
  </script>
</body>
</html>